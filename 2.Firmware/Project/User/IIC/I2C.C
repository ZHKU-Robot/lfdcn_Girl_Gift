#include "I2C.H"
#include <CH552.H>
#include "UART.H"
#include <stdio.h>
#include "Debug.H"

sbit SDA=P1^7; /*模拟I2C 数据传送位*/
sbit SCL=P1^4; /*模拟I2C 时钟控制位*/
bit ack; /*应答标志位*/

/*******************************************************************
起动总线函数
函数原型: void Start_I2c();
功能: 启动I2C 总线,即发送I2C 起始条件.
********************************************************************/
void Start_I2c()
{
	SDA=1; /*发送起始条件的数据信号*/
	_Nop();
	SCL=1;
	_Nop(); /*起始条件建立时间大于4.7us,延时*/
	_Nop();
	_Nop();
	_Nop();
	_Nop();
	SDA=0; /*发送起始信号*/
	_Nop(); /* 起始条件锁定时间大于4μs*/
	_Nop();
	_Nop();
	_Nop();
	_Nop();
	SCL=0; /*钳住I2C 总线，准备发送或接收数据 */
	_Nop();
	_Nop();
}
/*******************************************************************
结束总线函数
函数原型: void Stop_I2c();
功能: 结束I2C 总线,即发送I2C 结束条件.
********************************************************************/
void Stop_I2c()
{
	SDA=0; /*发送结束条件的数据信号*/
	_Nop(); /*发送结束条件的时钟信号*/
	SCL=1; /*结束条件建立时间大于4μs*/
	_Nop();
	_Nop();
	_Nop();
	_Nop();
	_Nop();
	SDA=1; /*发送I2C 总线结束信号*/
	_Nop();
	_Nop();
	_Nop();
	_Nop();
}
/*******************************************************************
字节数据传送函数
函数原型: void SendByte(UINT8 c);
功能: 将数据c 发送出去,可以是地址,也可以是数据,发完后等待应答,并对
此状态位进行操作.(不应答或非应答都使ack=0 假)
发送数据正常，ack=1; ack=0 表示被控器无应答或损坏。
********************************************************************/
void SendByte(UINT8 c)
{
	UINT8 BitCnt;
	for(BitCnt=0; BitCnt<8; BitCnt++) { /*要传送的数据长度为8 位*/
		if((c<<BitCnt)&0x80)SDA=1; /*判断发送位*/
		else SDA=0;
		_Nop();
		SCL=1; /*置时钟线为高，通知被控器开始接收数据位*/
		_Nop();
		_Nop(); /*保证时钟高电平周期大于4μs*/
		_Nop();
		_Nop();
		_Nop();
		SCL=0;
	}
	_Nop();
	_Nop();
	SDA=1; /*8 位发送完后释放数据线，准备接收应答位*/
	_Nop();
	_Nop();
	SCL=1;
	_Nop();
	_Nop();
	_Nop();
	if(SDA==1)ack=0;
	else ack=1; /*判断是否接收到应答信号*/
	SCL=0;
	_Nop();
	_Nop();
}
/*******************************************************************
字节数据传送函数
函数原型: UINT8 RcvByte();
功能: 用来接收从器件传来的数据,并判断总线错误(不发应答信号)，
发完后请用应答函数。
********************************************************************/
UINT8 RcvByte()
{
	UINT8 retc;
	UINT8 BitCnt;
	retc=0;
	SDA=1; /*置数据线为输入方式*/
	for(BitCnt=0; BitCnt<8; BitCnt++) {
		_Nop();
		SCL=0; /*置时钟线为低，准备接收数据位*/
		_Nop();
		_Nop(); /*时钟低电平周期大于4.7μs*/
		_Nop();
		_Nop();
		_Nop();
		SCL=1; /*置时钟线为高使数据线上数据有效*/
		_Nop();
		_Nop();
		retc=retc<<1;
		if(SDA==1)retc=retc+1; /*读数据位,接收的数据位放入retc 中 */
		_Nop();
		_Nop();
	}
	SCL=0;
	_Nop();
	_Nop();
	return(retc);
}
/********************************************************************
应答子函数
原型: void Ack_I2c(bit a);
功能:主控器进行应答信号,(可以是应答或非应答信号)
********************************************************************/
void Ack_I2c(bit a)
{
	if(a==0)SDA=0; /*在此发出应答或非应答信号 */
	else SDA=1;
	_Nop();
	_Nop();
	_Nop();
	SCL=1;
	_Nop();
	_Nop(); /*时钟低电平周期大于4μs*/
	_Nop();
	_Nop();
	_Nop();
	SCL=0; /*清时钟线，钳住I2C 总线以便继续接收*/
	_Nop();
	_Nop();
}
/*******************************************************************
向无子地址器件发送字节数据函数
函数原型: bit ISendByte(UINT8 sla,ucahr c);
功能: 从启动总线到发送地址，数据，结束总线的全过程,从器件地址sla.
如果返回1 表示操作成功，否则操作有误。
注意： 使用前必须已结束总线。
********************************************************************/
bit ISendByte(UINT8 sla,UINT8 c)
{
	Start_I2c(); /*启动总线*/
	SendByte(sla); /*发送器件地址*/
	if(ack==0)return(0);
	SendByte(c); /*发送数据*/
	if(ack==0)return(0);
	Stop_I2c(); /*结束总线*/
	return(1);
}
/*******************************************************************
向有子地址器件发送多字节数据函数
函数原型: bit ISendStr(UINT8 sla,UINT8 suba,UINT8 *s,UINT8 no);
功能: 从启动总线到发送地址，子地址,数据，结束总线的全过程,从器件
地址sla，子地址suba，发送内容是s 指向的内容，发送no 个字节。
如果返回1 表示操作成功，否则操作有误。
注意： 使用前必须已结束总线。
********************************************************************/
bit ISendStr(UINT8 sla,UINT8 suba,UINT8 *s,UINT8 no)
{
	UINT8 i;
	Start_I2c(); /*启动总线*/
	SendByte(sla); /*发送器件地址*/
	if(ack==0)return(0);
	SendByte(suba); /*发送器件子地址*/
	if(ack==0)return(0);
	for(i=0; i<no; i++) {
		SendByte(*s); /*发送数据*/
		if(ack==0)return(0);
		s++;
	}
	Stop_I2c(); /*结束总线*/
	return(1);
}
/*******************************************************************
向无子地址器件读字节数据函数
函数原型: bit IRcvByte(UINT8 sla,UINT8 *c);
功能: 从启动总线到发送地址，读数据，结束总线的全过程,从器件地
址sla，返回值在c.
如果返回1 表示操作成功，否则操作有误。
注意： 使用前必须已结束总线。
********************************************************************/
bit IRcvByte(UINT8 sla,UINT8 *c)
{
	Start_I2c(); /*启动总线*/
	SendByte(sla+1); /*发送器件地址*/
	if(ack==0)return(0);
	*c=RcvByte(); /*读取数据*/
	Ack_I2c(1); /*发送非就答位*/
	Stop_I2c(); /*结束总线*/
	return(1);
}
/*******************************************************************
向有子地址器件读取多字节数据函数
函数原型: bit ISendStr(UINT8 sla,UINT8 suba,ucahr *s,UINT8 no);
功能: 从启动总线到发送地址，子地址,读数据，结束总线的全过程,从器件
地址sla，子地址suba，读出的内容放入s 指向的存储区，读no 个字节。
如果返回1 表示操作成功，否则操作有误。
注意： 使用前必须已结束总线。
********************************************************************/
UINT8 IRcvStr(UINT8 sla,UINT8 suba,UINT8 *s,UINT8 no)
{
	UINT8 i;
	Start_I2c(); /*启动总线*/
	SendByte(sla); /*发送器件地址*/
	if(ack==0)
	{
		printf("CODE:1");
		return 0;
	}
	SendByte(suba); /*发送器件子地址*/
	if(ack==0)
	{
		printf("CODE:2");
		return 0;
	}
	Start_I2c();
	SendByte(sla+1);
	if(ack==0)
	{
		printf("CODE:3");
		return 0;
	}
	for(i=0; i<no-1; i++) {
		*s=RcvByte(); /*发送数据*/
		Ack_I2c(0); /*发送就答位*/
		s++;
	}
	*s=RcvByte();
	Ack_I2c(1); /*发送非应位*/
	Stop_I2c(); /*结束总线*/
	return(1);
}

/*********************************************************************************************
函数名：读出LM75A的温度值（-55~125摄氏度）
调  用：LM75A_GetTemp();
参  数：无
返回值：无
结  果：将温度数据写入3个LM75的全局变量
备  注：需要3个全局变量（bit LM75_N;//0正1负 UINT8 LM75_T,LM75_P;//整数,小数值十进制）
/**********************************************************************************************/
void LM75A_GetTemp( )
{
	UINT8 buf[2]; //温度值储存
	UINT8 t=0,a=0;
	IRcvStr(LM75A_ADD,0x00,buf,2);
	t = buf[0]; //处理温度整数部分，0~125度
	LM75_N = 0; //温度值为正值
	if(t & 0x80) { //判断温度是否是负极（MSB表示温度符号）
		LM75_N
		= 1; //温度值为负值
		t = ~t;
		t++; //计算补码（原码取反后加1）
	}
	if(t & 0x01) {
		a=a+1;    //从高到低按位加入温度积加值（0~125）
	}
	if(t & 0x02) {
		a=a+2;
	}
	if(t & 0x04) {
		a=a+4;
	}
	if(t & 0x08) {
		a=a+8;
	}
	if(t & 0x10) {
		a=a+16;
	}
	if(t & 0x20) {
		a=a+32;
	}
	if(t & 0x40) {
		a=a+64;
	}
	LM75_T = a;
	a = 0;
	t = buf[1]; //处理小数部分，取0.125精度的前2位（12、25、37、50、62、75、87）
	if(t & 0x20) {
		a=a+12;
	}
	if(t & 0x40) {
		a=a+25;
	}
	if(t & 0x80) {
		a=a+50;
	}
	LM75_P = a;
}
