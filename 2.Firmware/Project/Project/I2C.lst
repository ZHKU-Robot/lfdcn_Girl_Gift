C51 COMPILER V9.60.0.0   I2C                                                               12/06/2020 14:28:35 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE I2C
OBJECT MODULE PLACED IN .\I2C.obj
COMPILER INVOKED BY: D:\keil4\C51\BIN\C51.EXE ..\User\IIC\I2C.C LARGE OPTIMIZE(8,SPEED) BROWSE NOAREGS INCDIR(..\Public;
                    -..\User\GPIO;..\User\PWM;..\User\Timer;..\User\ADC;..\User\Compare;..\User\DataFlash;..\User\IAP;..\User\SPI;..\User\Tou
                    -chKey;..\User\USB\USB_LIB;..\User\IIC;..\User\UART;..\User\Timer;..\User\RZ) DEBUG OBJECTEXTEND PRINT(.\I2C.lst) OBJECT(
                    -.\I2C.obj)

line level    source

   1          #include "I2C.H"
   2          #include <CH552.H>
   3          #include "UART.H"
   4          #include <stdio.h>
   5          #include "Debug.H"
   6          
   7          sbit SDA=P1^7; /*模拟I2C 数据传送位*/
   8          sbit SCL=P1^4; /*模拟I2C 时钟控制位*/
   9          bit ack; /*应答标志位*/
  10          
  11          /*******************************************************************
  12          起动总线函数
  13          函数原型: void Start_I2c();
  14          功能: 启动I2C 总线,即发送I2C 起始条件.
  15          ********************************************************************/
  16          void Start_I2c()
  17          {
  18   1              SDA=1; /*发送起始条件的数据信号*/
  19   1              _Nop();
  20   1              SCL=1;
  21   1              _Nop(); /*起始条件建立时间大于4.7us,延时*/
  22   1              _Nop();
  23   1              _Nop();
  24   1              _Nop();
  25   1              _Nop();
  26   1              SDA=0; /*发送起始信号*/
  27   1              _Nop(); /* 起始条件锁定时间大于4μs*/
  28   1              _Nop();
  29   1              _Nop();
  30   1              _Nop();
  31   1              _Nop();
  32   1              SCL=0; /*钳住I2C 总线，准备发送或接收数据 */
  33   1              _Nop();
  34   1              _Nop();
  35   1      }
  36          /*******************************************************************
  37          结束总线函数
  38          函数原型: void Stop_I2c();
  39          功能: 结束I2C 总线,即发送I2C 结束条件.
  40          ********************************************************************/
  41          void Stop_I2c()
  42          {
  43   1              SDA=0; /*发送结束条件的数据信号*/
  44   1              _Nop(); /*发送结束条件的时钟信号*/
  45   1              SCL=1; /*结束条件建立时间大于4μs*/
  46   1              _Nop();
  47   1              _Nop();
  48   1              _Nop();
  49   1              _Nop();
  50   1              _Nop();
  51   1              SDA=1; /*发送I2C 总线结束信号*/
  52   1              _Nop();
C51 COMPILER V9.60.0.0   I2C                                                               12/06/2020 14:28:35 PAGE 2   

  53   1              _Nop();
  54   1              _Nop();
  55   1              _Nop();
  56   1      }
  57          /*******************************************************************
  58          字节数据传送函数
  59          函数原型: void SendByte(UINT8 c);
  60          功能: 将数据c 发送出去,可以是地址,也可以是数据,发完后等待应答,并对
  61          此状态位进行操作.(不应答或非应答都使ack=0 假)
  62          发送数据正常，ack=1; ack=0 表示被控器无应答或损坏。
  63          ********************************************************************/
  64          void SendByte(UINT8 c)
  65          {
  66   1              UINT8 BitCnt;
  67   1              for(BitCnt=0; BitCnt<8; BitCnt++) { /*要传送的数据长度为8 位*/
  68   2                      if((c<<BitCnt)&0x80)SDA=1; /*判断发送位*/
  69   2                      else SDA=0;
  70   2                      _Nop();
  71   2                      SCL=1; /*置时钟线为高，通知被控器开始接收数据位*/
  72   2                      _Nop();
  73   2                      _Nop(); /*保证时钟高电平周期大于4μs*/
  74   2                      _Nop();
  75   2                      _Nop();
  76   2                      _Nop();
  77   2                      SCL=0;
  78   2              }
  79   1              _Nop();
  80   1              _Nop();
  81   1              SDA=1; /*8 位发送完后释放数据线，准备接收应答位*/
  82   1              _Nop();
  83   1              _Nop();
  84   1              SCL=1;
  85   1              _Nop();
  86   1              _Nop();
  87   1              _Nop();
  88   1              if(SDA==1)ack=0;
  89   1              else ack=1; /*判断是否接收到应答信号*/
  90   1              SCL=0;
  91   1              _Nop();
  92   1              _Nop();
  93   1      }
  94          /*******************************************************************
  95          字节数据传送函数
  96          函数原型: UINT8 RcvByte();
  97          功能: 用来接收从器件传来的数据,并判断总线错误(不发应答信号)，
  98          发完后请用应答函数。
  99          ********************************************************************/
 100          UINT8 RcvByte()
 101          {
 102   1              UINT8 retc;
 103   1              UINT8 BitCnt;
 104   1              retc=0;
 105   1              SDA=1; /*置数据线为输入方式*/
 106   1              for(BitCnt=0; BitCnt<8; BitCnt++) {
 107   2                      _Nop();
 108   2                      SCL=0; /*置时钟线为低，准备接收数据位*/
 109   2                      _Nop();
 110   2                      _Nop(); /*时钟低电平周期大于4.7μs*/
 111   2                      _Nop();
 112   2                      _Nop();
 113   2                      _Nop();
 114   2                      SCL=1; /*置时钟线为高使数据线上数据有效*/
C51 COMPILER V9.60.0.0   I2C                                                               12/06/2020 14:28:35 PAGE 3   

 115   2                      _Nop();
 116   2                      _Nop();
 117   2                      retc=retc<<1;
 118   2                      if(SDA==1)retc=retc+1; /*读数据位,接收的数据位放入retc 中 */
 119   2                      _Nop();
 120   2                      _Nop();
 121   2              }
 122   1              SCL=0;
 123   1              _Nop();
 124   1              _Nop();
 125   1              return(retc);
 126   1      }
 127          /********************************************************************
 128          应答子函数
 129          原型: void Ack_I2c(bit a);
 130          功能:主控器进行应答信号,(可以是应答或非应答信号)
 131          ********************************************************************/
 132          void Ack_I2c(bit a)
 133          {
 134   1              if(a==0)SDA=0; /*在此发出应答或非应答信号 */
 135   1              else SDA=1;
 136   1              _Nop();
 137   1              _Nop();
 138   1              _Nop();
 139   1              SCL=1;
 140   1              _Nop();
 141   1              _Nop(); /*时钟低电平周期大于4μs*/
 142   1              _Nop();
 143   1              _Nop();
 144   1              _Nop();
 145   1              SCL=0; /*清时钟线，钳住I2C 总线以便继续接收*/
 146   1              _Nop();
 147   1              _Nop();
 148   1      }
 149          /*******************************************************************
 150          向无子地址器件发送字节数据函数
 151          函数原型: bit ISendByte(UINT8 sla,ucahr c);
 152          功能: 从启动总线到发送地址，数据，结束总线的全过程,从器件地址sla.
 153          如果返回1 表示操作成功，否则操作有误。
 154          注意： 使用前必须已结束总线。
 155          ********************************************************************/
 156          bit ISendByte(UINT8 sla,UINT8 c)
 157          {
 158   1              Start_I2c(); /*启动总线*/
 159   1              SendByte(sla); /*发送器件地址*/
 160   1              if(ack==0)return(0);
 161   1              SendByte(c); /*发送数据*/
 162   1              if(ack==0)return(0);
 163   1              Stop_I2c(); /*结束总线*/
 164   1              return(1);
 165   1      }
 166          /*******************************************************************
 167          向有子地址器件发送多字节数据函数
 168          函数原型: bit ISendStr(UINT8 sla,UINT8 suba,UINT8 *s,UINT8 no);
 169          功能: 从启动总线到发送地址，子地址,数据，结束总线的全过程,从器件
 170          地址sla，子地址suba，发送内容是s 指向的内容，发送no 个字节。
 171          如果返回1 表示操作成功，否则操作有误。
 172          注意： 使用前必须已结束总线。
 173          ********************************************************************/
 174          bit ISendStr(UINT8 sla,UINT8 suba,UINT8 *s,UINT8 no)
 175          {
 176   1              UINT8 i;
C51 COMPILER V9.60.0.0   I2C                                                               12/06/2020 14:28:35 PAGE 4   

 177   1              Start_I2c(); /*启动总线*/
 178   1              SendByte(sla); /*发送器件地址*/
 179   1              if(ack==0)return(0);
 180   1              SendByte(suba); /*发送器件子地址*/
 181   1              if(ack==0)return(0);
 182   1              for(i=0; i<no; i++) {
 183   2                      SendByte(*s); /*发送数据*/
 184   2                      if(ack==0)return(0);
 185   2                      s++;
 186   2              }
 187   1              Stop_I2c(); /*结束总线*/
 188   1              return(1);
 189   1      }
 190          /*******************************************************************
 191          向无子地址器件读字节数据函数
 192          函数原型: bit IRcvByte(UINT8 sla,UINT8 *c);
 193          功能: 从启动总线到发送地址，读数据，结束总线的全过程,从器件地
 194          址sla，返回值在c.
 195          如果返回1 表示操作成功，否则操作有误。
 196          注意： 使用前必须已结束总线。
 197          ********************************************************************/
 198          bit IRcvByte(UINT8 sla,UINT8 *c)
 199          {
 200   1              Start_I2c(); /*启动总线*/
 201   1              SendByte(sla+1); /*发送器件地址*/
 202   1              if(ack==0)return(0);
 203   1              *c=RcvByte(); /*读取数据*/
 204   1              Ack_I2c(1); /*发送非就答位*/
 205   1              Stop_I2c(); /*结束总线*/
 206   1              return(1);
 207   1      }
 208          /*******************************************************************
 209          向有子地址器件读取多字节数据函数
 210          函数原型: bit ISendStr(UINT8 sla,UINT8 suba,ucahr *s,UINT8 no);
 211          功能: 从启动总线到发送地址，子地址,读数据，结束总线的全过程,从器件
 212          地址sla，子地址suba，读出的内容放入s 指向的存储区，读no 个字节。
 213          如果返回1 表示操作成功，否则操作有误。
 214          注意： 使用前必须已结束总线。
 215          ********************************************************************/
 216          UINT8 IRcvStr(UINT8 sla,UINT8 suba,UINT8 *s,UINT8 no)
 217          {
 218   1              UINT8 i;
 219   1              Start_I2c(); /*启动总线*/
 220   1              SendByte(sla); /*发送器件地址*/
 221   1              if(ack==0)
 222   1              {
 223   2                      printf("CODE:1");
 224   2                      return 0;
 225   2              }
 226   1              SendByte(suba); /*发送器件子地址*/
 227   1              if(ack==0)
 228   1              {
 229   2                      printf("CODE:2");
 230   2                      return 0;
 231   2              }
 232   1              Start_I2c();
 233   1              SendByte(sla+1);
 234   1              if(ack==0)
 235   1              {
 236   2                      printf("CODE:3");
 237   2                      return 0;
 238   2              }
C51 COMPILER V9.60.0.0   I2C                                                               12/06/2020 14:28:35 PAGE 5   

 239   1              for(i=0; i<no-1; i++) {
 240   2                      *s=RcvByte(); /*发送数据*/
 241   2                      Ack_I2c(0); /*发送就答位*/
 242   2                      s++;
 243   2              }
 244   1              *s=RcvByte();
 245   1              Ack_I2c(1); /*发送非应位*/
 246   1              Stop_I2c(); /*结束总线*/
 247   1              return(1);
 248   1      }
 249          
 250          /*********************************************************************************************
 251          函数名：读出LM75A的温度值（-55~125摄氏度）
 252          调  用：LM75A_GetTemp();
 253          参  数：无
 254          返回值：无
 255          结  果：将温度数据写入3个LM75的全局变量
 256          备  注：需要3个全局变量（bit LM75_N;//0正1负 UINT8 LM75_T,LM75_P;//整数,小数值十进制）
 257          /**********************************************************************************************/
 258          void LM75A_GetTemp( )
 259          {
 260   1              UINT8 buf[2]; //温度值储存
 261   1              UINT8 t=0,a=0;
 262   1              IRcvStr(LM75A_ADD,0x00,buf,2);
 263   1              t = buf[0]; //处理温度整数部分，0~125度
 264   1              LM75_N = 0; //温度值为正值
 265   1              if(t & 0x80) { //判断温度是否是负极（MSB表示温度符号）
 266   2                      LM75_N
 267   2                      = 1; //温度值为负值
 268   2                      t = ~t;
 269   2                      t++; //计算补码（原码取反后加1）
 270   2              }
 271   1              if(t & 0x01) {
 272   2                      a=a+1;    //从高到低按位加入温度积加值（0~125）
 273   2              }
 274   1              if(t & 0x02) {
 275   2                      a=a+2;
 276   2              }
 277   1              if(t & 0x04) {
 278   2                      a=a+4;
 279   2              }
 280   1              if(t & 0x08) {
 281   2                      a=a+8;
 282   2              }
 283   1              if(t & 0x10) {
 284   2                      a=a+16;
 285   2              }
 286   1              if(t & 0x20) {
 287   2                      a=a+32;
 288   2              }
 289   1              if(t & 0x40) {
 290   2                      a=a+64;
 291   2              }
 292   1              LM75_T = a;
 293   1              a = 0;
 294   1              t = buf[1]; //处理小数部分，取0.125精度的前2位（12、25、37、50、62、75、87）
 295   1              if(t & 0x20) {
 296   2                      a=a+12;
 297   2              }
 298   1              if(t & 0x40) {
 299   2                      a=a+25;
 300   2              }
C51 COMPILER V9.60.0.0   I2C                                                               12/06/2020 14:28:35 PAGE 6   

 301   1              if(t & 0x80) {
 302   2                      a=a+50;
 303   2              }
 304   1              LM75_P = a;
 305   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    626    ----
   CONSTANT SIZE    =     21    ----
   XDATA SIZE       =   ----      15
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
